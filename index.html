<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js 魔方</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #111;
      }
      #app {
        width: 100%;
        height: 100%;
      }
      #ui {
        position: fixed;
        top: 12px;
        left: 12px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 10px;
        z-index: 10;
        user-select: none;
      }
      #ui button {
        cursor: pointer;
        color: #eaeaea;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 8px;
        padding: 6px 10px;
        min-width: 38px;
      }
      #ui button:hover {
        background: rgba(255, 255, 255, 0.14);
      }
      #ui button:active {
        background: rgba(255, 255, 255, 0.2);
      }
      #ui button.disabled {
        cursor: not-allowed;
        opacity: 0.5;
      }
      #ui .sep {
        width: 100%;
        height: 0;
      }
      #ui .prime-buttons {
        display: contents; /* 让内部按钮融入 flex 布局 */
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <button id="btnScramble">Scramble</button>
      <button id="btnReset">Reset</button>
      <div class="sep"></div>
      <button class="move" data-move="U">U</button>
      <button class="move" data-move="D">D</button>
      <button class="move" data-move="L">L</button>
      <button class="move" data-move="R">R</button>
      <button class="move" data-move="F">F</button>
      <button class="move" data-move="B">B</button>
      <div class="sep"></div>
      <div class="prime-buttons">
        <button class="move" data-move="U'">U'</button>
        <button class="move" data-move="D'">D'</button>
        <button class="move" data-move="L'">L'</button>
        <button class="move" data-move="R'">R'</button>
        <button class="move" data-move="F'">F'</button>
        <button class="move" data-move="B'">B'</button>
      </div>
    </div>
    <div id="app"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
      import gsap from "gsap";

      // --- 基本场景设置 ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222222);
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(3, 3, 4);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById("app").appendChild(renderer.domElement);

      // --- 光照与控制 ---
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 8, 6);
      scene.add(dirLight);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // --- 魔方核心变量 ---
      const cubies = [];
      let isAnimating = false;
      const COLOR_MAP = { W: 0xffffff, Y: 0xffff00, O: 0xff8c00, R: 0xff0000, G: 0x00aa00, B: 0x0000ff };

      // --- 魔方创建 ---
      function createRubiksCube() {
        const size = 0.95;
        const geom = new THREE.BoxGeometry(size, size, size);
        for (let x = -1; x <= 1; x++) {
          for (let y = -1; y <= 1; y++) {
            for (let z = -1; z <= 1; z++) {
              if (x === 0 && y === 0 && z === 0) continue; // 中心块不可见，跳过
              const materials = Array.from({ length: 6 }, () => new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
              const cubie = new THREE.Mesh(geom, materials);
              cubie.position.set(x, y, z);
              cubie.userData.grid = new THREE.Vector3(x, y, z);
              const edges = new THREE.EdgesGeometry(geom);
              const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
              cubie.add(line);
              cubies.push(cubie);
              scene.add(cubie);
            }
          }
        }
      }

      // --- 核心动画逻辑 ---
      function getLayer(face) {
        const layers = {
          U: cubies.filter((c) => Math.round(c.userData.grid.y) === 1),
          D: cubies.filter((c) => Math.round(c.userData.grid.y) === -1),
          L: cubies.filter((c) => Math.round(c.userData.grid.x) === -1),
          R: cubies.filter((c) => Math.round(c.userData.grid.x) === 1),
          F: cubies.filter((c) => Math.round(c.userData.grid.z) === 1),
          B: cubies.filter((c) => Math.round(c.userData.grid.z) === -1),
        };
        return layers[face];
      }

      function rotateLayer(face, direction = 1) {
        if (isAnimating) return;
        isAnimating = true;
        toggleButtons(false);

        const layer = getLayer(face);
        const pivot = new THREE.Group();
        scene.add(pivot);
        layer.forEach((cubie) => pivot.attach(cubie));

        const axisMap = { U: 'y', D: 'y', L: 'x', R: 'x', F: 'z', B: 'z' };
        const angle = (Math.PI / 2) * direction * (['D', 'L', 'B'].includes(face) ? -1 : 1);

        gsap.to(pivot.rotation, {
          [axisMap[face]]: angle,
          duration: 0.4,
          ease: "power2.inOut",
          onComplete: () => {
            scene.remove(pivot);
            layer.forEach((cubie) => {
              scene.attach(cubie);
              // 更新逻辑坐标
              const axis = new THREE.Vector3();
              if (axisMap[face] === 'x') axis.set(1, 0, 0);
              if (axisMap[face] === 'y') axis.set(0, 1, 0);
              if (axisMap[face] === 'z') axis.set(0, 0, 1);

              // 使用旋转矩阵进行精确变换，避免浮点数误差
              const rotationMatrix = new THREE.Matrix4().makeRotationAxis(axis, angle);
              cubie.userData.grid.applyMatrix4(rotationMatrix);
              cubie.userData.grid.round(); // 四舍五入到最近的整数坐标
            });
            isAnimating = false;
            toggleButtons(true);
          },
        });
      }

      // --- 后端通信 & 颜色更新 ---
      async function fetchStateAndApplyColors() {
        try {
          const resp = await fetch("http://localhost:8000/state");
          if (!resp.ok) throw new Error(`获取状态失败: ${resp.status}`);
          const data = await resp.json();
          updateCubeColors(data);
        } catch (e) {
          console.error(e);
          alert("无法从后端获取魔方状态，请确认 FastAPI 服务已启动。\n" + e);
        }
      }

      function updateCubeColors(stateData) {
        for (const cubie of cubies) {
          const { x, y, z } = cubie.userData.grid;
          const mats = cubie.material;
          // 重置所有面为暗色
          mats.forEach(m => m.color.setHex(0x1a1a1a));
          
          const faceSticker = (face, row, col) => stateData?.[face]?.[row]?.[col];

          if (x === 1)  { const ch = faceSticker("R", 1 - y, 1 - z); if(ch) mats[0].color.setHex(COLOR_MAP[ch]); }
          if (x === -1) { const ch = faceSticker("L", 1 - y, 1 + z); if(ch) mats[1].color.setHex(COLOR_MAP[ch]); }
          if (y === 1)  { const ch = faceSticker("U", 1 + z, 1 + x); if(ch) mats[2].color.setHex(COLOR_MAP[ch]); }
          if (y === -1) { const ch = faceSticker("D", 1 - z, 1 + x); if(ch) mats[3].color.setHex(COLOR_MAP[ch]); }
          if (z === 1)  { const ch = faceSticker("F", 1 - y, 1 + x); if(ch) mats[4].color.setHex(COLOR_MAP[ch]); }
          if (z === -1) { const ch = faceSticker("B", 1 - y, 1 - x); if(ch) mats[5].color.setHex(COLOR_MAP[ch]); }
        }
      }

      // --- UI 绑定 ---
      function toggleButtons(enabled) {
        document.querySelectorAll("#ui button").forEach(b => b.classList.toggle('disabled', !enabled));
      }

      document.getElementById("btnReset").addEventListener("click", async () => {
        if (isAnimating) return;
        try {
          await fetch("http://localhost:8000/reset");
          await fetchStateAndApplyColors();
        } catch (e) { console.error(e); alert(e); }
      });

      document.getElementById("btnScramble").addEventListener("click", async () => {
        if (isAnimating) return;
        try {
          const resp = await fetch("http://localhost:8000/scramble", { method: "POST", headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ steps: 20 }) });
          const data = await resp.json();
          updateCubeColors(data.state);
        } catch (e) { console.error(e); alert(e); }
      });

      document.querySelectorAll("#ui button.move").forEach((btn) => {
        btn.addEventListener("click", () => {
          const move = btn.dataset.move;
          const face = move[0];
          const direction = move.includes("'") ? -1 : 1;
          rotateLayer(face, direction);
          // 后台同步状态
          fetch("http://localhost:8000/move", { method: "POST", headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ move }) });
        });
      });

      // --- 渲染循环 & 初始化 ---
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      createRubiksCube();
      fetchStateAndApplyColors();
      animate();
    </script>
  </body>
</html>
