<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js 测试场景</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #111;
      }
      #app {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

      // 关键：给 OrbitControls 提供 import map，避免其内部 `import 'three'` 解析失败

      // 1) Scene / Camera / Renderer
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222222);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(2.5, 2.0, 2.5);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById("app").appendChild(renderer.domElement);

      // 2) Lights
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);

      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(3, 5, 4);
      scene.add(dir);

      // 3) OrbitControls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // 4) Rubik's Cube (3x3x3 cubies)
      const cubies = [];

      // 1) 颜色映射：后端字符 -> hex
      const COLOR_MAP = {
        W: 0xffffff,
        Y: 0xffff00,
        O: 0xff8c00,
        R: 0xff0000,
        G: 0x00aa00,
        B: 0x0000ff,
      };

      function createRubiksCube() {
        const group = new THREE.Group();

        const size = 0.95; // 留缝隙
        const geom = new THREE.BoxGeometry(size, size, size);

        for (let x = -1; x <= 1; x++) {
          for (let y = -1; y <= 1; y++) {
            for (let z = -1; z <= 1; z++) {
              // 每个 cubie 使用 6 个材质，对应 BoxGeometry 的面索引：
              // 0:Right(+X), 1:Left(-X), 2:Up(+Y), 3:Down(-Y), 4:Front(+Z), 5:Back(-Z)
              const materials = Array.from({ length: 6 }, () =>
                new THREE.MeshStandardMaterial({ color: 0x888888 })
              );

              const cubie = new THREE.Mesh(geom, materials);
              cubie.position.set(x, y, z);

              // 用于和后端 state 对齐的“离散坐标”
              cubie.userData.grid = { x, y, z };

              // 黑色边框线：用于清晰展示格子轮廓
              const edges = new THREE.EdgesGeometry(geom);
              const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x000000 })
              );
              cubie.add(line);

              cubies.push(cubie);
              group.add(cubie);
            }
          }
        }

        scene.add(group);
        return group;
      }

      createRubiksCube();

      // 4) 初始化：页面加载后拉取一次后端状态并上色
      fetchState().catch((e) => {
        console.error(e);
        alert("无法从后端获取魔方状态，请确认 FastAPI 已在 http://localhost:8000 启动，并且已允许 CORS。\n\n" + e);
      });

      // 2) 状态获取
      async function fetchState() {
        const resp = await fetch("http://localhost:8000/state");
        if (!resp.ok) {
          throw new Error(`获取状态失败: ${resp.status} ${resp.statusText}`);
        }
        const data = await resp.json();
        updateCubeColors(data);
        return data;
      }

      // 3) 核心上色：坐标 -> (面, row, col) -> 材质索引
      function updateCubeColors(stateData) {
        // 约定：Three.js 里我们用 z=+1 作为 Front，z=-1 作为 Back。
        // 下面的 (row,col) 映射是可校准的；我加了少量 console.log 便于你对照实物/后端。

        const faceSticker = (face, row, col) => {
          const ch = stateData?.[face]?.[row]?.[col];
          return ch;
        };

        for (const cubie of cubies) {
          const { x, y, z } = cubie.userData.grid;
          const mats = cubie.material;

          // Right (+X) -> state['R']
          if (x === 1) {
            const row = 1 - y; // y:1->0, 0->1, -1->2
            const col = 1 - z; // z:1->0, 0->1, -1->2
            const ch = faceSticker("R", row, col);
            if (ch) mats[0].color.setHex(COLOR_MAP[ch] ?? 0x888888);
          }
          // Left (-X) -> state['L']
          if (x === -1) {
            const row = 1 - y;
            const col = 1 + z; // z:-1->0,0->1,1->2
            const ch = faceSticker("L", row, col);
            if (ch) mats[1].color.setHex(COLOR_MAP[ch] ?? 0x888888);
          }
          // Up (+Y) -> state['U']
          if (y === 1) {
            const row = 1 + z; // z:-1->0,0->1,1->2（从后到前）
            const col = 1 + x; // x:-1->0,0->1,1->2（从左到右）
            const ch = faceSticker("U", row, col);
            if (ch) mats[2].color.setHex(COLOR_MAP[ch] ?? 0x888888);
          }
          // Down (-Y) -> state['D']
          if (y === -1) {
            const row = 1 - z; // z:1->0,0->1,-1->2（从前到后）
            const col = 1 + x;
            const ch = faceSticker("D", row, col);
            if (ch) mats[3].color.setHex(COLOR_MAP[ch] ?? 0x888888);
          }
          // Front (+Z) -> state['F']
          if (z === 1) {
            const row = 1 - y;
            const col = 1 + x;
            const ch = faceSticker("F", row, col);
            if (ch) mats[4].color.setHex(COLOR_MAP[ch] ?? 0x888888);
          }
          // Back (-Z) -> state['B']
          if (z === -1) {
            const row = 1 - y;
            const col = 1 - x; // x:1->0,0->1,-1->2（从右到左）
            const ch = faceSticker("B", row, col);
            if (ch) mats[5].color.setHex(COLOR_MAP[ch] ?? 0x888888);
          }
        }

        // 调试：打印几个角块对应的 state 取值，便于校准 (row,col) 方向
        const sample = cubies.find((c) => c.userData.grid.x === 1 && c.userData.grid.y === 1 && c.userData.grid.z === 1);
        if (sample) {
          const { x, y, z } = sample.userData.grid;
          console.log("角块(+1,+1,+1) 采样", { x, y, z }, "U[?]", stateData.U?.[2]?.[2], "R[?]", stateData.R?.[0]?.[0], "F[?]", stateData.F?.[0]?.[2]);
        }
      }

      // 5) Resize handling
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // 6) Render loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>

